(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,27657,e=>{"use strict";var t=e.i(2885),o=e.i(97122),n=e.i(64458),s=e.i(15052);function a({active:e=!1,classes:o,merge:a=n.default,...i}){let r=(0,s.useRef)(null),[h,c]=(0,s.useState)();return((0,s.useEffect)(()=>{if(!i.children||!r.current)return;r.current?.normalize();let e=[];for(let o of Array.from(r.current.childNodes)){var t;if((t=o).nodeType!==t.TEXT_NODE)continue;let n=o.wholeText.split(" "),s=n.shift(),a=s;o.replaceData(0,o.wholeText.length,a);let i=r.current.getBoundingClientRect().height;for(let t of n){o.replaceData(0,o.wholeText.length,`${a} ${t}`);let n=r.current.getBoundingClientRect().height;n!==i?(i=n,e.push(s),s=t):s+=` ${t}`,a+=` ${t}`}e.push(s)}c(e)},[i.children]),i.children)?(0,t.jsxs)("div",{className:a(o?.container,e&&o?.active,!e&&o?.inactive)||void 0,"data-active":e||void 0,children:[(0,t.jsx)("dt",{className:o?.cue,children:i.on}),h?h.map((e,n)=>(0,t.jsx)("dd",{className:o?.line,children:e},n)):(0,t.jsx)("dd",{className:o?.measure,ref:r,children:i.children})]}):null}var i=e.i(69139),r=e.i(48956);function h({children:e,...o}){let{markers:n}=(0,r.useScript)(),a=(0,s.useRef)(null);(0,s.useEffect)(()=>{a.current&&(a.current.style.left||Object.assign(a.current.style,{left:"0%",top:"0%"}))});let h=(0,s.useMemo)(()=>{let e,t;return(0,i.onDrag)((o,n)=>{if(!a.current)return;let s=function(e){if(void 0!==e.offsetLeft&&void 0!==e.offsetTop&&e.offsetParent)return{height:e.offsetParent.getBoundingClientRect().height,left:e.offsetLeft,top:e.offsetTop,width:e.offsetParent.getBoundingClientRect().width};let t=e.getBoundingClientRect(),o=e;for(;o=o.parentNode;){if(!["absolute","relative"].includes(getComputedStyle(o).position))continue;let e=o.getBoundingClientRect();return{height:e.height,left:t.left-e.left,top:t.top-e.top,width:e.width}}return{height:innerHeight,left:t.left,top:t.top,width:innerWidth}}(a.current),i=s.left+n.x-e,r=s.top+n.y-t,h=i/s.width*100,c=r/s.height*100;e=n.x,t=n.y,Object.assign(a.current.style,{left:`${h}%`,top:`${c}%`})},(o,n)=>{e=n.x,t=n.y})},[]);return(0,t.jsx)("dl",{className:"lv-prompt",...o,...h,ref:a,children:e})}let c=e=>{let s,a,i=(0,o.c)(3);return i[0]===Symbol.for("react.memo_cache_sentinel")?(s=(0,n.default)("absolute z-100 hidden w-[35em] shadow-lg","overflow-hidden rounded-sm","text-white","*:hidden *:data-active:block [&>[data-active]~*]:block","[&>:not([data-active])]:opacity-40"),i[0]=s):s=i[0],i[1]!==e?(a=(0,t.jsx)(h,{className:s,...e}),i[1]=e,i[2]=a):a=i[2],a},l=e=>{let n,s,i=(0,o.c)(3);return i[0]===Symbol.for("react.memo_cache_sentinel")?(n={cue:"bg-orange-500 font-mono py-[.2em] px-[.1em] text-[14px]",line:"odd:bg-gray-400 even:bg-gray-600 py-1 px-[.2em]",measure:"block py-1 px-[.2em]"},i[0]=n):n=i[0],i[1]!==e?(s=(0,t.jsx)(a,{classes:n,...e}),i[1]=e,i[2]=s):s=i[2],s};e.s(["EquivScript",0,e=>{let n,s,a,i,r,h,p,d,m,f,u,y=(0,o.c)(12);return y[0]===Symbol.for("react.memo_cache_sentinel")?(n=(0,t.jsx)(l,{on:"equiv/",children:"First let's show that paths are a special case of homotopies. If we've got two points"}),s=(0,t.jsx)(l,{on:"equiv/pts",children:"x and y in the space X, a point of a space can be viewed as"}),a=(0,t.jsx)(l,{on:"equiv/fn",children:"a *map* from the one-point space into X. This might seem a little strange at first but this is a really useful point of view to take. In this instance, if we think about these points as maps, then we see that a homotopy between these two maps"}),i=(0,t.jsx)(l,{on:"equiv/text",children:"is exactly the same thing as a path in X from x to y."}),r=(0,t.jsx)(l,{on:"equiv/reverso",children:"And we can go in the other direction."}),h=(0,t.jsx)(l,{on:"equiv/bi",children:"So initially we defined a homotopy as a map from X cross I to Y, so the domain is basically a cylinder whose cross-sections are homeomorphic to X. This is just encoding a function of two variables, one variable comes from X, another is a time parameter coming from the unit interval. But there's other ways to describe functions of multiple variables."}),p=(0,t.jsx)(l,{on:"equiv/path",children:"We could view this as a function from X to the space of maps from I to Y, so from X to the space of paths in Y,"}),d=(0,t.jsx)(l,{on:"equiv/maps",children:"or we could view it as a map from I to the space of maps from X to Y, so a path from f to g inside the mapping space from X to Y."}),m=(0,t.jsx)(l,{on:"equiv/warning",children:"You do need to be a little bit careful with point-set topology here, so when I say Map(X, Y), this has"}),y[0]=n,y[1]=s,y[2]=a,y[3]=i,y[4]=r,y[5]=h,y[6]=p,y[7]=d,y[8]=m):(n=y[0],s=y[1],a=y[2],i=y[3],r=y[4],h=y[5],p=y[6],d=y[7],m=y[8]),y[9]===Symbol.for("react.memo_cache_sentinel")?(f=(0,t.jsxs)(l,{on:"equiv/compact-open",children:["the compact-open topology in order to view it as a space in its own right, and then you have to say certain adjectives in order for these three perspectives to *really* be interchangeable; but that's a technical point that we can worry about later.",(0,t.jsx)("br",{}),"Anyway, what I'd like to do next is just keep playing around with the definition from these different perspectives."]}),y[9]=f):f=y[9],y[10]!==e?(u=(0,t.jsxs)(c,{...e,children:[n,s,a,i,r,h,p,d,m,f]}),y[10]=e,y[11]=u):u=y[11],u},"HtpyScript",0,e=>{let n,s,a,i,r,h,p=(0,o.c)(7);return p[0]===Symbol.for("react.memo_cache_sentinel")?(n=(0,t.jsx)(l,{on:"htpy/",children:"and that's the notion of a homotopy. So let's say we've got"}),s=(0,t.jsx)(l,{on:"htpy/fg",children:"two continuous maps f and g between spaces X and Y,"}),a=(0,t.jsx)(l,{on:"htpy/dfn",children:"a *homotopy* from f to g is a map H from X cross the unit interval to Y such that H(-, 0) = f and H(-, 1) = g. So for any t in the unit interval, if we fix that argument, H(-, t) is a map from X to Y. And we want that to start at f and end at g. So we're saying that we can continuously interpolate between the functions f and g."}),p[0]=n,p[1]=s,p[2]=a):(n=p[0],s=p[1],a=p[2]),p[3]===Symbol.for("react.memo_cache_sentinel")?(i=(0,t.jsx)("br",{}),p[3]=i):i=p[3],p[4]===Symbol.for("react.memo_cache_sentinel")?(r=(0,t.jsxs)(l,{on:"htpy/htpic",children:["And we say that two functions are *homotopic* if there exists a homotopy between them.",i,"In algebraic topology, we will consider two maps equivalent if they're homotopic. In some ways this is a pretty drastic equivalence relation, it destroys a lot of the information you would see in general topology and geometry when considering spaces up to homeomorphism or diffeomorphism. But we'll see that this actually retains a shocking amount of information about a space.",(0,t.jsx)("br",{}),"What I'd like to talk about next is that paths and homotopy subsume one another."]}),p[4]=r):r=p[4],p[5]!==e?(h=(0,t.jsxs)(c,{...e,children:[n,s,a,r]}),p[5]=e,p[6]=h):h=p[6],h},"PathScript",0,e=>{let n,s,a,i,r,h,p,d,m,f,u=(0,o.c)(11);return u[0]===Symbol.for("react.memo_cache_sentinel")?(n=(0,t.jsx)(l,{on:"path/title",children:"One of the starting points of algebraic topology is the notion of a path."}),s=(0,t.jsx)(l,{on:"path/X",children:"So if X is a topological space,"}),a=(0,t.jsx)(l,{on:"path/xy",children:"and x and y are points of X,"}),i=(0,t.jsx)(l,{on:"path/dfn",children:"a *path* from x to y is formally defined as"}),r=(0,t.jsx)(l,{on:"path/alpha",children:"a map alpha from the closed unit interval to X,"}),h=(0,t.jsx)(l,{on:"path/alpha-bdry",children:"such that alpha(0) = x, and alpha(1) = y."}),u[0]=n,u[1]=s,u[2]=a,u[3]=i,u[4]=r,u[5]=h):(n=u[0],s=u[1],a=u[2],i=u[3],r=u[4],h=u[5]),u[6]===Symbol.for("react.memo_cache_sentinel")?(p=(0,t.jsxs)(l,{on:"path/demo",children:["So you can experiment with this in the demo on the right.",(0,t.jsx)("br",{}),"So one of the basic qualitative questions we can ask about a space is whether it's always possible to find a path connecting any two points."]}),d=(0,t.jsx)(l,{on:"path/connected",children:"So we say that a space is *path-connected* if for any two points x and y, we can find a path connecting them. For example the sphere is path-connected, but if we look at the surface"}),u[6]=p,u[7]=d):(p=u[6],d=u[7]),u[8]===Symbol.for("react.memo_cache_sentinel")?(m=(0,t.jsxs)(l,{on:"path/disconnected",children:["cut out by the equations z^2 = xy - 1, we can see this consists of two distinct pieces, and there's no way to connect the given points by a path. So we'll formalize this in the next lecture, we'll show that the property of being connected by a path is an equivalence relation on the points of X.",(0,t.jsx)("br",{}),"In general we're going to be interested in a parametrized version of paths,"]}),u[8]=m):m=u[8],u[9]!==e?(f=(0,t.jsxs)(c,{...e,children:[n,s,a,i,r,h,p,d,m]}),u[9]=e,u[10]=f):f=u[10],f},"RewriteScript",0,e=>{let n,s,a,i,r,h,p=(0,o.c)(7);return p[0]===Symbol.for("react.memo_cache_sentinel")?(n=(0,t.jsx)(l,{on:"rewrite/",children:"So remember the setup for talking about homotopies is we start out with two spaces X and Y and two maps f and g from X to Y. So having two maps from X to Y is the same"}),s=(0,t.jsx)(l,{on:"rewrite/amalg",children:"as having one combined map from the coproduct of X with itself to Y. That's the universal property of the coproduct. And then X disjoint union X, well that's the same as"}),a=(0,t.jsx)(l,{on:"rewrite/S0",children:"X cross the 0-sphere, S^0. Remember S^0 consists of two points, +/- 1. So the 0-sphere is the boundary of the 1-disk, so there's an inclusion map"}),i=(0,t.jsx)(l,{on:"rewrite/arrow",children:"from X cross S^0 to X cross D^1, which is the same as X cross I. And then asking for a homotopy between f and g is asking,"}),r=(0,t.jsx)(l,{on:"rewrite/fill",children:"for a map from X cross D^1 to Y making this diagram commute. So this way of phrasing things suggests a generalization to higher-dimensional spheres, and just as a general principle, in algebraic topology it's very useful to express problems in terms of trying to fill in some diagram."}),p[0]=n,p[1]=s,p[2]=a,p[3]=i,p[4]=r):(n=p[0],s=p[1],a=p[2],i=p[3],r=p[4]),p[5]!==e?(h=(0,t.jsxs)(c,{...e,children:[n,s,a,i,r]}),p[5]=e,p[6]=h):h=p[6],h},"SceneScript",0,e=>{let n,s,a,i,r,h,p=(0,o.c)(7);return p[0]===Symbol.for("react.memo_cache_sentinel")?(n=(0,t.jsx)(l,{on:"scene/",children:"So here's a visualization of this. In this case X is S^1, so we've got two maps from the circle to the torus, or two loops on the torus. A homotopy between these loops means extending the domain"}),s=(0,t.jsx)(l,{on:"scene/cylinder",children:"to a cylinder, so that by taking cross-sections of the cylinder we get a family of loops interpolating between these two. In this case, it is possible to write down such a homotopy,"}),a=(0,t.jsx)(l,{on:"scene/slider",children:"so you can try dragging the orange cross section on the cylinder to see the homotopy of loops carried out over on the torus. I'll pause the video so you can play around with that; just press the play button when you're ready to continue."}),i=(0,t.jsx)(l,{on:"scene/pause",children:'So even though these two loops look sort of different, they\'re homotopic, which formalizes the idea that they "wrap around the torus in the same way". On the other hand, if we looked at'}),p[0]=n,p[1]=s,p[2]=a,p[3]=i):(n=p[0],s=p[1],a=p[2],i=p[3]),p[4]===Symbol.for("react.memo_cache_sentinel")?(r=(0,t.jsxs)(l,{on:"scene/not",children:["these two loops, you should try to convince yourself, at least intuitively, that there's no possible way to homotope the red loop into the blue loop. And we're going to develop tools that will allow us to prove this rigorously.",(0,t.jsx)("br",{}),"So again, from the mapping space persepctive, each of these loops is a point in the space of maps from the circle to the torus, and we're saying that there's no path between those two points. One big advantage of this mapping space perspective is"]}),p[4]=r):r=p[4],p[5]!==e?(h=(0,t.jsxs)(c,{...e,children:[n,s,a,i,r]}),p[5]=e,p[6]=h):h=p[6],h},"SubScript",0,e=>{let n,s,a,i,r,h,p,d,m=(0,o.c)(9);return m[0]===Symbol.for("react.memo_cache_sentinel")?(n=(0,t.jsx)(l,{on:"sub/",children:"that we can consider subspaces of mapping spaces. What do I mean by this, well"}),s=(0,t.jsx)(l,{on:"sub/often",children:"it's often the case that want to impose certain conditions on a homotopy."}),a=(0,t.jsx)(l,{on:"sub/based",children:"For example, our spaces will often come equipped with a chosen basepoint, and we're going to want to look at maps sending the basepoint of X to the basepoint of Y. In this context, the correct notion of homotopy to consider is a"}),i=(0,t.jsx)(l,{on:"sub/based-H",children:"*based* homotopy, so it's a homotopy where we insist that all the intermediate functions are also based. So a slick way to encode this is"}),r=(0,t.jsx)(l,{on:"sub/XY",children:"to think about a homotopy as a path in the mapping space, and now ask instead"}),h=(0,t.jsx)(l,{on:"sub/A",children:"for paths in an appropriate *subspace* of Map(X,Y). So in this case"}),m[0]=n,m[1]=s,m[2]=a,m[3]=i,m[4]=r,m[5]=h):(n=m[0],s=m[1],a=m[2],i=m[3],r=m[4],h=m[5]),m[6]===Symbol.for("react.memo_cache_sentinel")?(p=(0,t.jsxs)(l,{on:"sub/{}",children:["A would be the subspace of based maps. But there's lots of other more complicated conditions we might impose on our homotopies, and these can all be treated within our existing framework of paths by considering appropriate subspaces of the mapping space.",(0,t.jsx)("br",{}),"In the next few lectures we'll explore the algebraic structure of paths, and use that to show that homotopy is an equivalence relation, and then start to prove some things about the homotopy of spaces."]}),m[6]=p):p=m[6],m[7]!==e?(d=(0,t.jsxs)(c,{...e,children:[n,s,a,i,r,h,p]}),m[7]=e,m[8]=d):d=m[8],d}],27657)}]);